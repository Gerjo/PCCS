\documentclass[acmtoplas,acmnow]{acmtrans2m}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newdef{definition}[theorem]{Definition}
\newdef{remark}[theorem]{Remark}
\markboth{Game Engine Development}{CpPhantom}
\title{C++ Phantom}
\author{Sander Brattinga\newline Nico Glas\newline Gerard Meier}
\begin{abstract} 
This article is intended for game engine creators. It will feature the development process. Why we did some nasty things and more.\newline
Some say they are geniuses, while others say they are just lunatics... all we know is they created an engine. (Jeremy Clarkson voice)
\end{abstract}

\category{Engine Development}{}{Game engine in C++ that simulates the HTML5 canvas.}

\terms{} 

\keywords{}
\begin{document}

\begin{bottomstuff}
\end{bottomstuff}

\maketitle
\section{Blastoff}
We actually first started thinking of a game. We developed the engine and game simultaneously so we knew instantly what we needed from the engine. The engine we created is component based and sort of like the Phantom flash game engine. 

\subsection{Design}
We wanted to create an engine that is HTML5 syntax compatible. This means we created a single context, canvas or what ever you want to call it. You can draw things with the same commands you expect to work in HTML5. This means the functions beginPath, rect, arc, lineTo and more are available to use.\newline
Another important point is that we wanted the engine to be completely component based. This makes it easy to create a nice hierarchy with almost unlimited possibilities.

\subsection{External dependencies}
For rendering we decided to use OpenGL. OpenGL is cross platform and commonly used for the rendering of graphics. For window creation, audio and input we decided on using SDL. During development we decided to change it to FreeGLUT. The reason for this was that FreeGLUT had less dependencies. Afterwards it was a very bad choice. SDL has a lot more useful features for engine development.

\section{The engine}

\subsection{Component architecture}
The engine is completely composite based. Almost everything is extending on the composite class. This way we can override the update function in every component so loop based events can easely be created. Because the update function is recursively called this created iterative issues. When a component gets deleted, the iterator gets incompatible. For this we made a destroy function and this adds the component to a list of components which gets deleted at the end of the game loop. 

\subsection{Graphics}
Ofcourse an engine needs to be able to display graphics on the screen. Using OpenGL we were able to create vertex buffer objects which are stored on the graphics card. Our textures are png images which are loaded using libpng. The engine only supports this format, we decided this was sufficient for us. PNG supports the alpha channel and is lossless. Using the graphics component we created shapes which are then build on the renderer. The renderer sends the shapes to the graphics card and sets a value as reference in the shape. The engine also features an easy to use particle engine. It only requires two lines of code to create particles.

\subsection{Audio}
For audio we needed to use something that was cross platform. OpenAL is a very good audio API for games. It supports positioning of the audio and realistic sound. You can even set the speed of sound and the doppler effect without much trouble. Also all sounds are buffered except the music. RAW audio can turn out to be pretty memory consuming.

\subsection{Input}
The input is handled by FreeGLUT. It's very easy to use but also very basic. Yet it was sufficient.

\subsection{Artificial Intelligence}
hints: Pathfinding

\subsection{Physics}
hints: Vector, InertiaMover, Pulses

\begin{thebibliography}{}

\end{thebibliography}

\begin{received}
\end{received}
\end{document}

